# About ARM Thumb
ARM Thumb指令集是ARM架构中的一种指令集，专为提高代码密度和性能而设计。Thumb指令集使用16位指令编码（部分扩展支持32位指令），相比传统的32位ARM指令集，能够显著减少代码大小，从而节省内存并提高缓存利用率。以下是关于Thumb指令集的汇编格式及常见指令的详细介绍。
## **一、Thumb指令集汇编格式**
Thumb指令集的汇编格式与标准ARM指令集类似，但有一些关键区别：
### **1. 指令长度：**
- Thumb指令通常是16位长。
- 在Thumb-2扩展中，某些复杂指令可以是32位长。
### **2. 寄存器命名：**
- 使用r0到r15表示通用寄存器。
- r13通常用作堆栈指针（SP）。
- r14通常用作链接寄存器（LR）。
- r15是程序计数器（PC）。
### **3. 条件执行：**
- Thumb指令集不支持所有指令的条件执行（与ARM指令集不同）。
- 条件分支指令（如B<cond>）仍然可用。
### **4. 立即数限制：**
- Thumb指令中的立即数通常受到限制（例如，只能使用8位或经过移位的值）。
### **5. 伪指令：**
- 汇编器支持一些伪指令（如.thumb、.syntax unified等），用于指定Thumb模式或统一语法。

---

## **二、常见Thumb指令**
以下是一些常见的Thumb指令及其功能：

### **1. 数据处理指令**
```armasm
-   MOV：将一个值移动到寄存器。
MOV r0, #10       ; 将立即数10加载到r0
MOV r1, r0        ; 将r0的值复制到r1
```
- ADD：加法操作。
```armasm
ADD r0, r1, #5    ; r0 = r1 + 5
ADD r2, r0, r1    ; r2 = r0 + r1
```
- SUB：减法操作。
```armasm
SUB r0, r1, #3    ; r0 = r1 - 3
SUB r2, r0, r1    ; r2 = r0 - r1
```
- AND：按位与操作。
```armasm
AND r0, r1, #0xFF ; r0 = r1 & 0xFF
```
- ORR：按位或操作。
```armasm
ORR r0, r1, #0x10 ; r0 = r1 | 0x10
```
- LSL/LSR：逻辑左移/右移。
```armasm
LSL r0, r1, #2    ; r0 = r1 << 2
LSR r0, r1, #3    ; r0 = r1 >> 3
```
### **2. 分支指令**
- B：无条件跳转。
```armasm
B label           ; 跳转到label
```
- BL：带链接的跳转（用于函数调用）。
```armasm
BL function       ; 调用function，并将返回地址存储在LR（r14）
```
- BX：根据寄存器值跳转（支持切换到ARM模式）。
```armasm
BX r0             ; 跳转到r0指向的地址
```
### **3. 内存访问指令**
- LDR/STR：加载/存储数据。
```armasm
LDR r0, [r1]      ; 将r1指向的内存地址中的值加载到r0
STR r0, [r1]      ; 将r0的值存储到r1指向的内存地址
```
- LDRB/STRB：加载/存储字节。
```armasm
LDRB r0, [r1]     ; 加载一个字节到r0
STRB r0, [r1]     ; 存储一个字节到r1指向的地址
```
### **4. 堆栈操作指令**
- PUSH/POP：压栈/出栈操作。
```armasm
PUSH {r0, r1}     ; 将r0和r1压入堆栈
POP {r0, r1}      ; 从堆栈弹出值到r0和r1
```
### **5. 状态寄存器操作**
- CPS：更改处理器状态。
```armasm
CPSID i           ; 禁用中断
CPSIE i           ; 启用中断
```
### **6. 其他指令**
- NOP：空操作。
```armasm
NOP               ; 不执行任何操作
```
- SVC：系统调用。
```armasm
SVC #0x12         ; 触发系统调用，编号为0x12
```
## **三、Thumb-2扩展指令**
Thumb-2是对Thumb指令集的扩展，引入了32位指令以支持更复杂的操作。以下是一些常见的Thumb-2指令：
1. IT：If-Then指令，用于条件执行。
```armasm
IT EQ            ; 如果条件为EQ，则执行下一条指令
ADD r0, r1, #1   ; 条件执行的加法操作
```
2. CBZ/CBNZ：比较并跳转（如果为零/非零）。
```armasm
CBZ r0, label    ; 如果r0为0，则跳转到label
CBNZ r0, label   ; 如果r0不为0，则跳转到label
```
3. TBB/TBH：表分支指令。
```armasm
TBB [r0]         ; 根据r0指向的表进行分支
```
---
## **四、示例代码**
以下是一个简单的Thumb汇编示例，计算两个数的和并将结果存储到内存中：
```armasm
.syntax unified
.thumb

.global _start

_start:
    MOV r0, #5          ; 将5加载到r0
    MOV r1, #10         ; 将10加载到r1
    ADD r2, r0, r1      ; r2 = r0 + r1
    LDR r3, =result     ; 加载result的地址到r3
    STR r2, [r3]        ; 将r2的值存储到result地址
    B end               ; 跳转到end

end:
    NOP                 ; 结束

.data
result: .word 0         ; 定义一个变量result，初始值为0
```
## ARM与Thumb模式下的 `LDR` 指令的偏移计算
### 1. **基本 `LDR` 指令**

#### **`LDR` 立即数偏移寻址**
```assembly
LDR R0, [PC, #offset]
```
- **功能**：从 `PC` 加上一个立即数偏移量处加载数据到寄存器 `R0`。
- **计算方式**：
  - **ARM 模式**：`PC` 的值是当前指令的地址加上 8。
  - **Thumb 模式**：`PC` 的值是当前指令的地址加上 4。
- **原因**：`PC` 在 `LDR` 指令执行时指向的是下一条指令的地址，因此需要加上一个偏移量来正确寻址。

### 2. **具体例子**

#### **ARM 模式**
假设当前指令地址为 `0x08000000`：
```assembly
0x08000000  LDR R0, [PC, #8]
```
- **PC 值**：`0x08000000 + 8 = 0x08000008`
- **实际地址**：`0x08000008 + 8 = 0x08000010`
- **加载数据**：从地址 `0x08000010` 加载数据到 `R0`。

#### **Thumb 模式**
假设当前指令地址为 `0x08000000`：
```assembly
0x08000000  LDR R0, [PC, #4]
```
- **PC 值**：`0x08000000 + 4 = 0x08000004`
- **实际地址**：`0x08000004 + 4 = 0x08000008`
- **加载数据**：从地址 `0x08000008` 加载数据到 `R0`。

### 3. **`LDR` 指令的其他变体**

#### **`LDR` 寄存器偏移寻址**
```assembly
LDR R0, [PC, R1]
```
- **功能**：从 `PC` 加上寄存器 `R1` 的值处加载数据到寄存器 `R0`。
- **计算方式**：
  - **ARM 模式**：`PC` 的值是当前指令的地址加上 8。
  - **Thumb 模式**：`PC` 的值是当前指令的地址加上 4。

#### **`LDR` 带立即数的 PC 相对寻址**
```assembly
LDR R0, =label
```
- **功能**：加载标签 `label` 的地址到寄存器 `R0`。
- **计算方式**：
  - **ARM 模式**：`PC` 的值是当前指令的地址加上 8。
  - **Thumb 模式**：`PC` 的值是当前指令的地址加上 4。

### 4. **具体到你的问题**

你提到 `LDR` 指令在 ARM 寻址时会将 `PC+4` 再加上立即数才能计算。这通常适用于 **Thumb 模式**，因为：

- **Thumb 模式**：`PC` 的值是当前指令的地址加上 4。
- **计算方式**：`PC + 4 + 立即数偏移量`。

例如：
```assembly
0x08000000  LDR R0, [PC, #4]
```
- **PC 值**：`0x08000000 + 4 = 0x08000004`
- **实际地址**：`0x08000004 + 4 = 0x08000008`
- **加载数据**：从地址 `0x08000008` 加载数据到 `R0`。

### 5. **总结**

- **ARM 模式**：
  - `PC` 的值是当前指令的地址加上 8。
  - 计算方式：`PC + 8 + 立即数偏移量`。

- **Thumb 模式**：
  - `PC` 的值是当前指令的地址加上 4。
  - 计算方式：`PC + 4 + 立即数偏移量`。

因此，如果你在 **Thumb 模式** 下使用 `LDR` 指令，并且使用立即数偏移量，确实会将 `PC+4` 再加上立即数来计算实际的地址。

如果你有更多具体的代码或上下文，可以提供进一步的详细信息，以便更准确地解释。